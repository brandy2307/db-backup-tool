{
  "_comment": "DO NOT EDIT: FILE GENERATED AUTOMATICALLY BY PANEL",
  "meta": {
    "version": "PTDL_v2",
    "update_url": "https://github.com/brandy2307/db-backup-tool/blob/main/dbtool-egg.json"
  },
  "exported_at": "2024-12-15T14:40:56+00:00",
  "name": "DB Backup Tool (Docker Fixed - No Snap)",
  "author": "brandy@example.com",
  "uuid": "db9f372e-01d7-4c9b-a109-e49990d68d46",
  "description": "Sicheres automatisiertes Datenbank-Backup-Tool mit SSL-Unterst√ºtzung - DOCKER KOMPATIBEL ohne Snap",
  "features": [
    "eula=false"
  ],
  "docker_images": {
    "ghcr.io/parkervcp/yolks:nodejs_18": "ghcr.io/parkervcp/yolks:nodejs_18"
  },
  "file_denylist": [],
  "startup": "cd /home/container && if [ ! -f \"db-backup-tool/package.json\" ]; then echo \"ERROR: package.json not found. Please reinstall the server.\"; exit 1; fi && cd db-backup-tool && npm start",
  "config": {
    "files": "{\r\n    \"db-backup-tool/config.json\": {\r\n        \"parser\": \"json\",\r\n        \"find\": {\r\n            \"server.port\": \"{{server.build.default.port}}\",\r\n            \"server.httpsPort\": \"{{env.HTTPS_PORT}}\",\r\n            \"server.host\": \"0.0.0.0\",\r\n            \"security.requireHttps\": \"{{env.REQUIRE_HTTPS}}\",\r\n            \"security.enable2FA\": \"{{env.ENABLE_2FA}}\",\r\n            \"security.strongPasswords\": \"{{env.STRONG_PASSWORDS}}\",\r\n            \"security.maxFailedAttempts\": \"{{env.MAX_FAILED_ATTEMPTS}}\",\r\n            \"security.defaultAdmin.username\": \"{{env.ADMIN_USERNAME}}\",\r\n            \"security.defaultAdmin.password\": \"{{env.ADMIN_PASSWORD}}\",\r\n            \"security.sessionSecret\": \"{{env.SESSION_SECRET}}\",\r\n            \"security.jwtSecret\": \"{{env.JWT_SECRET}}\",\r\n            \"ssl.domain\": \"{{env.SSL_DOMAIN}}\",\r\n            \"ssl.email\": \"{{env.SSL_EMAIL}}\",\r\n            \"ssl.method\": \"{{env.SSL_METHOD}}\",\r\n            \"ssl.autoRenewal\": \"{{env.SSL_AUTO_RENEWAL}}\",\r\n            \"ssl.keySize\": \"{{env.SSL_KEY_SIZE}}\",\r\n            \"ssl.certValidity\": \"{{env.SSL_CERT_VALIDITY}}\",\r\n            \"ssl.setupOnStart\": \"{{env.SSL_SETUP_ON_START}}\",\r\n            \"backup.maxBackups\": \"{{env.MAX_BACKUPS}}\",\r\n            \"backup.compression\": \"{{env.ENABLE_COMPRESSION}}\",\r\n            \"gitBackup.enabled\": \"{{env.GIT_BACKUP_ENABLED}}\",\r\n            \"gitBackup.repository\": \"{{env.GIT_BACKUP_REPOSITORY}}\",\r\n            \"gitBackup.username\": \"{{env.GIT_BACKUP_USERNAME}}\",\r\n            \"gitBackup.branch\": \"{{env.GIT_BACKUP_BRANCH}}\",\r\n            \"updates.autoUpdate\": \"{{env.AUTO_UPDATE}}\"\r\n        }\r\n    }\r\n}",
    "startup": "{\r\n    \"done\": \"Server l√§uft auf\"\r\n}",
    "logs": "{}",
    "stop": "^C"
  },
  "scripts": {
    "installation": {
      "script": "#!/bin/bash\n# Docker-Kompatible Database Backup Tool Installation - OHNE SNAP\n\nset -e\n\ndeclare -r DIR=\"/mnt/server\"\ndeclare -r APP_DIR=\"${DIR}/db-backup-tool\"\n\n# Fest definiertes Repository\nREPO_URL=\"https://github.com/brandy2307/db-backup-tool.git\"\nREPO_BRANCH=\"main\"\n\necho \"=================================================\"\necho \"DB BACKUP TOOL INSTALLATION (DOCKER COMPATIBLE)\"\necho \"=================================================\"\necho \"Repository: ${REPO_URL}\"\necho \"Branch: ${REPO_BRANCH}\"\necho \"Target: ${APP_DIR}\"\necho \"Features: Docker-Fixed SSL + Let's Encrypt + 2FA\"\necho \"Note: No Snap support in Docker - using APT only\"\necho \"=================================================\"\n\n# System Dependencies installieren\necho \"[1/9] Installing system dependencies...\"\napt update\napt install -y wget curl gnupg2 software-properties-common git openssl ca-certificates lsb-release\n\n# Node.js installieren\necho \"[2/9] Installing Node.js 18...\"\ncurl -fsSL https://deb.nodesource.com/setup_18.x | bash -\napt install -y nodejs\n\n# Database Tools installieren\necho \"[3/9] Installing database tools...\"\napt install -y mysql-client || apt install -y default-mysql-client || echo \"MySQL client installation failed (optional)\"\napt install -y postgresql-client || apt install -y postgresql-client-common || echo \"PostgreSQL client installation failed (optional)\"\n\n# MongoDB Tools\necho \"Installing MongoDB tools...\"\nwget -qO - https://www.mongodb.org/static/pgp/server-7.0.asc | gpg --dearmor -o /usr/share/keyrings/mongodb-server-7.0.gpg\necho \"deb [ arch=amd64,arm64 signed-by=/usr/share/keyrings/mongodb-server-7.0.gpg ] https://repo.mongodb.org/apt/debian $(lsb_release -cs)/mongodb-org/7.0 main\" | tee /etc/apt/sources.list.d/mongodb-org-7.0.list\napt update\napt install -y mongodb-database-tools || echo \"MongoDB tools installation failed (optional)\"\n\n# DOCKER-FIXED: Certbot ohne Snap installieren\necho \"[4/9] Installing SSL and security tools (DOCKER COMPATIBLE)...\"\necho \"Installing Certbot via APT (Docker compatible)...\"\n\n# Certbot √ºber APT installieren (Docker-kompatibel)\necho \"Installing Certbot via APT repository...\"\n\n# Debian/Ubuntu Certbot Installation\nif command -v apt-get >/dev/null 2>&1; then\n    # Backports Repository f√ºr neuere Certbot-Version\n    echo \"deb http://deb.debian.org/debian $(lsb_release -cs)-backports main\" > /etc/apt/sources.list.d/backports.list || true\n    apt update\n    \n    # Certbot installieren\n    apt install -y certbot python3-certbot-nginx python3-certbot-apache || {\n        # Fallback ohne Plugins\n        apt install -y certbot || {\n            # Fallback mit pip\n            echo \"APT installation failed, trying pip...\"\n            apt install -y python3-pip\n            pip3 install certbot\n        }\n    }\nelse\n    echo \"‚ùå APT not available, Certbot installation skipped\"\nfi\n\n# Certbot Installation verifizieren\nif command -v certbot >/dev/null 2>&1; then\n    echo \"‚úÖ Certbot successfully installed via APT\"\n    CERTBOT_VERSION=$(certbot --version 2>/dev/null || echo \"version check failed\")\n    echo \"Certbot version: $CERTBOT_VERSION\"\nelse\n    echo \"‚ö†Ô∏è Certbot installation failed - will use self-signed fallback\"\nfi\n\n# Zus√§tzliche SSL Tools\napt install -y openssl ca-certificates\napt install -y fail2ban || echo \"Fail2ban installation failed (optional)\"\n\n# Git konfigurieren\necho \"[5/9] Configuring Git...\"\ngit config --global init.defaultBranch main\ngit config --global user.name \"DB Backup Tool\"\ngit config --global user.email \"backup@localhost\"\ngit config --global http.postBuffer 524288000\ngit config --global core.compression 0\n\n# Tools verifikation\necho \"[6/9] Verifying installed tools...\"\necho \"Node.js: $(node --version)\"\necho \"NPM: $(npm --version)\"\necho \"Git: $(git --version)\"\necho \"OpenSSL: $(openssl version)\"\necho \"Certbot: $(certbot --version 2>/dev/null || echo 'Not available - will use self-signed')\"\necho \"Docker Environment: Detected (Snap disabled)\"\n\n# Wechsel zum Zielverzeichnis\ncd \"${DIR}\"\n\n# Alte Installation entfernen\nif [ -d \"${APP_DIR}\" ]; then\n    echo \"Removing old installation...\"\n    rm -rf \"${APP_DIR}\"\nfi\n\n# Repository Setup\necho \"[7/9] Setting up official repository...\"\necho \"Cloning from: ${REPO_URL}\"\n\nif ! git ls-remote --heads \"${REPO_URL}\" >/dev/null 2>&1; then\n    echo \"ERROR: Repository '${REPO_URL}' is not accessible!\"\n    exit 1\nfi\n\necho \"Cloning repository...\"\nif ! git clone -b \"${REPO_BRANCH}\" \"${REPO_URL}\" \"${APP_DIR}\"; then\n    echo \"ERROR: Git clone failed!\"\n    exit 1\nfi\n\ncd \"${APP_DIR}\"\necho \"Repository cloned to: $(pwd)\"\n\n# Pr√ºfe kritische Dateien\necho \"Verifying critical files...\"\nCRITICAL_FILES=(\n    \"package.json\"\n    \"server.js\"\n    \"config.json\"\n    \"public/index.html\"\n    \"public/app.js\"\n    \"public/styles.css\"\n)\n\nfor file in \"${CRITICAL_FILES[@]}\"; do\n    if [ ! -f \"$file\" ]; then\n        echo \"ERROR: Critical file missing: $file\"\n        exit 1\n    fi\ndone\n\necho \"‚úì All critical files found\"\n\n# Dependencies installieren\necho \"[8/9] Installing dependencies...\"\nnpm cache clean --force\n\nif npm install --production --no-audit --no-fund; then\n    echo \"‚úì Dependencies installed successfully\"\nelif npm install --production --legacy-peer-deps --no-audit --no-fund; then\n    echo \"‚úì Dependencies installed with legacy-peer-deps\"\nelif npm install --production --force --no-audit --no-fund; then\n    echo \"‚úì Dependencies installed with force flag\"\nelse\n    echo \"ERROR: Failed to install dependencies\"\n    exit 1\nfi\n\n# Verzeichnisse erstellen\necho \"Creating directories with proper permissions...\"\nmkdir -p backups logs config public ssl\nchmod 700 ssl\nchmod 755 backups logs config public\nchmod 755 .\n\n# DOCKER-FIXED: SSL-Setup Script f√ºr Docker-Umgebung\necho \"[9/9] Setting up Docker-compatible SSL certificates...\"\nif [ \"${SSL_SETUP_ON_START:-true}\" = \"true\" ] && [ \"${REQUIRE_HTTPS:-false}\" = \"true\" ]; then\n    echo \"üîê SSL-Setup aktiviert - Docker-kompatible Version...\"\n    \n    # Umgebungsvariablen setzen\n    export SSL_DOMAIN=\"${SSL_DOMAIN:-localhost}\"\n    export SSL_EMAIL=\"${SSL_EMAIL:-admin@localhost}\"\n    export SSL_METHOD=\"${SSL_METHOD:-selfsigned}\"\n    export SSL_KEY_SIZE=\"${SSL_KEY_SIZE:-4096}\"\n    export SSL_CERT_VALIDITY=\"${SSL_CERT_VALIDITY:-365}\"\n    \n    echo \"Domain: ${SSL_DOMAIN}, Method: ${SSL_METHOD}, Email: ${SSL_EMAIL}\"\n    \n    # Docker-kompatibles SSL-Setup Script erstellen\n    cat > ./ssl-setup.sh << 'EOFSSL'\n#!/bin/bash\n# Docker-Kompatibles SSL Setup Script (ohne Snap)\nset -e\n\nSSL_DOMAIN=\"${SSL_DOMAIN:-localhost}\"\nSSL_EMAIL=\"${SSL_EMAIL:-admin@localhost}\"\nSSL_METHOD=\"${SSL_METHOD:-selfsigned}\"\nSSL_KEY_SIZE=\"${SSL_KEY_SIZE:-4096}\"\nSSL_CERT_VALIDITY=\"${SSL_CERT_VALIDITY:-365}\"\n\necho \"üîê Docker-Kompatibles SSL Setup f√ºr ${SSL_DOMAIN} mit Methode: ${SSL_METHOD}\"\necho \"‚ö†Ô∏è Docker Environment erkannt - Snap nicht verf√ºgbar\"\n\n# SSL Verzeichnis erstellen\nmkdir -p ssl\nchmod 700 ssl\n\ncase \"${SSL_METHOD}\" in\n    \"letsencrypt\")\n        echo \"üîÑ Let's Encrypt Setup (Docker-Modus)...\"\n        \n        # Domain Validierung\n        if [ \"${SSL_DOMAIN}\" = \"localhost\" ] || [ \"${SSL_DOMAIN}\" = \"127.0.0.1\" ]; then\n            echo \"‚ùå Let's Encrypt funktioniert nicht mit localhost\"\n            echo \"üîÑ Wechsle zu Self-Signed Fallback\"\n            SSL_METHOD=\"selfsigned\"\n        else\n            # Certbot in Docker pr√ºfen\n            CERTBOT_CMD=\"\"\n            if command -v certbot >/dev/null 2>&1; then\n                CERTBOT_CMD=\"certbot\"\n                echo \"‚úÖ Certbot gefunden (Docker-APT): ${CERTBOT_CMD}\"\n            else\n                echo \"‚ùå Certbot nicht verf√ºgbar in Docker\"\n                echo \"üîÑ Wechsle zu Self-Signed Fallback\"\n                SSL_METHOD=\"selfsigned\"\n            fi\n            \n            if [ \"${SSL_METHOD}\" = \"letsencrypt\" ]; then\n                echo \"üîÑ Versuche Let's Encrypt in Docker-Umgebung...\"\n                \n                # Docker-spezifische Let's Encrypt Herausforderung\n                # Warnung: Let's Encrypt ben√∂tigt Port 80 von au√üen erreichbar\n                echo \"‚ö†Ô∏è WICHTIG: Port 80 muss von au√üen erreichbar sein!\"\n                echo \"‚ö†Ô∏è Docker-Container m√ºssen Port 80 f√ºr HTTP-Challenge freigeben!\"\n                \n                # Let's Encrypt mit Docker-optimierten Einstellungen\n                if \"${CERTBOT_CMD}\" certonly \\\n                    --standalone \\\n                    --non-interactive \\\n                    --agree-tos \\\n                    --email \"${SSL_EMAIL}\" \\\n                    --domains \"${SSL_DOMAIN}\" \\\n                    --preferred-challenges http \\\n                    --http-01-port 80 \\\n                    --rsa-key-size \"${SSL_KEY_SIZE}\" \\\n                    --force-renewal \\\n                    --no-verify-ssl; then\n                    \n                    # Zertifikate kopieren\n                    CERT_PATH=\"/etc/letsencrypt/live/${SSL_DOMAIN}\"\n                    if [ -d \"${CERT_PATH}\" ]; then\n                        cp \"${CERT_PATH}/fullchain.pem\" ssl/fullchain.pem\n                        cp \"${CERT_PATH}/privkey.pem\" ssl/privkey.pem\n                        echo \"‚úÖ Let's Encrypt Zertifikat erfolgreich erstellt (Docker)\"\n                    else\n                        echo \"‚ùå Zertifikat-Pfad nicht gefunden\"\n                        SSL_METHOD=\"selfsigned\"\n                    fi\n                else\n                    echo \"‚ùå Let's Encrypt fehlgeschlagen in Docker\"\n                    echo \"M√∂gliche Ursachen:\"\n                    echo \"  - Port 80 nicht von au√üen erreichbar\"\n                    echo \"  - Domain zeigt nicht auf diesen Server\"\n                    echo \"  - Docker-Netzwerk-Konfiguration\"\n                    echo \"üîÑ Wechsle zu Self-Signed Fallback\"\n                    SSL_METHOD=\"selfsigned\"\n                fi\n            fi\n        fi\n        \n        # Fallback zu Self-Signed\n        if [ \"${SSL_METHOD}\" = \"selfsigned\" ]; then\n            ;&\n        fi\n        ;;\n        \n    \"selfsigned\")\n        echo \"üîÑ Erstelle Self-Signed Zertifikat (Docker-optimiert)...\"\n        \n        # OpenSSL Konfiguration f√ºr Docker\n        cat > ssl/openssl.cnf << EOFCERT\n[req]\ndistinguished_name = req_distinguished_name\nreq_extensions = v3_req\nprompt = no\n\n[req_distinguished_name]\nC = DE\nST = NRW\nL = Docker\nO = DB Backup Tool Docker\nCN = ${SSL_DOMAIN}\n\n[v3_req]\nkeyUsage = keyEncipherment, dataEncipherment\nextendedKeyUsage = serverAuth\nsubjectAltName = @alt_names\n\n[alt_names]\nDNS.1 = ${SSL_DOMAIN}\nDNS.2 = *.${SSL_DOMAIN}\nDNS.3 = localhost\nDNS.4 = *.localhost\nIP.1 = 127.0.0.1\nIP.2 = ::1\nIP.3 = 0.0.0.0\nEOFCERT\n\n        # Self-Signed Zertifikat mit erweiterten Docker-Einstellungen\n        openssl req -x509 -newkey rsa:\"${SSL_KEY_SIZE}\" \\\n            -keyout ssl/privkey.pem \\\n            -out ssl/fullchain.pem \\\n            -days \"${SSL_CERT_VALIDITY}\" \\\n            -nodes \\\n            -config ssl/openssl.cnf \\\n            -extensions v3_req\n        \n        # Cleanup\n        rm -f ssl/openssl.cnf\n        \n        echo \"‚úÖ Self-Signed Zertifikat erfolgreich erstellt (Docker)\"\n        ;;\n        \n    \"manual\")\n        echo \"üîÑ Pr√ºfe manuelle Zertifikate...\"\n        \n        if [ ! -f \"ssl/fullchain.pem\" ] || [ ! -f \"ssl/privkey.pem\" ]; then\n            echo \"‚ùå Manuelle Zertifikate nicht gefunden\"\n            echo \"üîÑ Wechsle zu Self-Signed Fallback\"\n            SSL_METHOD=\"selfsigned\"\n            # Rekursiver Aufruf\n            exec \"$0\"\n        else\n            echo \"‚úÖ Manuelle Zertifikate gefunden\"\n        fi\n        ;;\n        \n    *)\n        echo \"‚ùå Unbekannte SSL-Methode: ${SSL_METHOD}\"\n        echo \"üîÑ Verwende Self-Signed als sicheren Fallback\"\n        SSL_METHOD=\"selfsigned\"\n        # Rekursiver Aufruf mit selfsigned\n        exec \"$0\"\n        ;;\nesac\n\n# Dateiberechtigungen setzen (Docker-sicher)\nchmod 644 ssl/fullchain.pem 2>/dev/null || true\nchmod 600 ssl/privkey.pem 2>/dev/null || true\n\n# Docker-spezifische Berechtigungen\nchown -R root:root ssl/ 2>/dev/null || true\n\n# Validierung\nif openssl x509 -in ssl/fullchain.pem -text -noout >/dev/null 2>&1; then\n    echo \"‚úÖ SSL-Zertifikat erfolgreich validiert (Docker)\"\n    echo \"üìã Zertifikat-Details:\"\n    openssl x509 -in ssl/fullchain.pem -subject -issuer -dates -noout\n    \n    # Docker-spezifische Informationen\n    echo \"üê≥ Docker-Environment: SSL bereit\"\n    echo \"‚ö†Ô∏è Browser-Warnung bei Self-Signed normal\"\nelse\n    echo \"‚ùå SSL-Zertifikat ung√ºltig\"\n    exit 1\nfi\n\necho \"üéâ Docker-kompatibles SSL-Setup erfolgreich abgeschlossen!\"\nEOFSSL\n\n    chmod +x ./ssl-setup.sh\n    \n    # SSL-Setup ausf√ºhren\n    echo \"üîÑ F√ºhre Docker-kompatibles SSL-Setup aus...\"\n    if ./ssl-setup.sh; then\n        echo \"‚úÖ SSL-Setup w√§hrend Installation erfolgreich (Docker)\"\n        \n        # Pr√ºfe ob Zertifikate erstellt wurden\n        if [ -f \"ssl/fullchain.pem\" ] && [ -f \"ssl/privkey.pem\" ]; then\n            echo \"‚úÖ SSL-Zertifikate erfolgreich erstellt (Docker)\"\n            echo \"üîê HTTPS ready for Docker environment!\"\n            ls -la ssl/\n        else\n            echo \"‚ö†Ô∏è SSL-Setup lief durch, aber Zertifikate nicht gefunden\"\n        fi\n    else\n        echo \"‚ö†Ô∏è SSL-Setup fehlgeschlagen - Server startet mit HTTP\"\n        echo \"HTTPS kann sp√§ter √ºber Web-Interface konfiguriert werden\"\n    fi\nelse\n    echo \"‚ÑπÔ∏è SSL-Setup √ºbersprungen (deaktiviert oder HTTP-Modus)\"\nfi\n\n# Finale Berechtigungen setzen\nchmod 755 .\nchmod 644 *.json *.js *.md 2>/dev/null || true\nchmod +x *.sh 2>/dev/null || true\nchmod 755 backups logs config public ssl\n\n# Package.json Verifikation\nif node -e \"JSON.parse(require('fs').readFileSync('package.json', 'utf8'))\" 2>/dev/null; then\n    echo \"‚úÖ package.json is valid\"\nelse\n    echo \"‚ùå package.json is invalid\"\n    exit 1\nfi\n\n# Security Files Setup\ntouch logs/security.log\nchmod 640 logs/security.log\n\n# Schedules File Setup\nif [ ! -f \"backups/schedules.json\" ]; then\n    echo \"[]\" > backups/schedules.json\n    chmod 644 backups/schedules.json\n    echo \"‚úÖ schedules.json created\"\nfi\n\n# .gitattributes Setup\nif [ ! -f \".gitattributes\" ]; then\n    echo \"* text=auto\" > .gitattributes\n    chmod 644 .gitattributes\n    echo \"‚úÖ .gitattributes created\"\nfi\n\n# Finale Verifikation\necho \"=================================================\"\necho \"INSTALLATION VERIFICATION (DOCKER COMPATIBLE)\"\necho \"=================================================\"\necho \"‚úÖ Repository: ${REPO_URL}\"\necho \"‚úÖ Branch: ${REPO_BRANCH}\"\necho \"‚úÖ Directory: $(pwd)\"\necho \"‚úÖ Node.js: $(node --version)\"\necho \"‚úÖ NPM: $(npm --version)\"\necho \"‚úÖ Package.json: Valid\"\necho \"‚úÖ SSL Support: Docker-Compatible (No Snap)\"\necho \"‚úÖ Certbot: $(command -v certbot >/dev/null && echo 'Available via APT' || echo 'Self-Signed Fallback')\"\necho \"‚úÖ Security Features: 2FA, CAPTCHA, Rate Limiting\"\necho \"‚úÖ Database Tools: MySQL, PostgreSQL, MongoDB\"\necho \"‚úÖ Git Backup: Supported\"\necho \"‚úÖ Auto-Update: Enabled\"\necho \"‚úÖ Docker Environment: Detected and Optimized\"\n\nif [ -f \"ssl/fullchain.pem\" ] && [ -f \"ssl/privkey.pem\" ]; then\n    echo \"‚úÖ SSL Certificates: Created during installation\"\n    echo \"üîê HTTPS ready to use in Docker!\"\n    if [ \"${SSL_METHOD}\" = \"selfsigned\" ]; then\n        echo \"‚ö†Ô∏è Self-Signed: Browser will show security warning (normal)\"\n    fi\nelse\n    echo \"‚ÑπÔ∏è SSL Certificates: Will be created on first start\"\nfi\n\necho \"=================================================\"\n\n# Startup Test\necho \"Performing startup test...\"\nif node -e \"console.log('Node.js startup test OK')\" 2>/dev/null; then\n    echo \"‚úÖ Node.js startup test passed\"\nelse\n    echo \"‚ùå Node.js startup test failed\"\n    exit 1\nfi\n\necho \"=================================================\"\necho \"üéâ INSTALLATION SUCCESSFUL! (DOCKER EDITION) üéâ\"\necho \"=================================================\"\necho \"Database Backup Tool (Docker Compatible) ready!\"\necho \"Features available:\"\necho \"  üîê Docker-Fixed HTTPS & SSL Certificate Management\"\necho \"  üõ°Ô∏è Two-Factor Authentication (2FA)\"\necho \"  ü§ñ CAPTCHA Protection\"\necho \"  üö´ Rate Limiting & Brute Force Protection\"\necho \"  üìä Session Management\"\necho \"  üîí Enhanced Security Headers\"\necho \"  üìã Audit Logging\"\necho \"  üì¶ Git Backup Integration\"\necho \"  üîÑ Automatic Updates\"\necho \"  üíæ Multi-Database Support\"\necho \"  üê≥ DOCKER OPTIMIZED - No Snap Dependencies\"\necho \"=================================================\"\necho \"üîß Configure via Pterodactyl Panel Environment Variables\"\necho \"üöÄ Start server to begin secure backup operations\"\necho \"üìù Note: Let's Encrypt in Docker requires Port 80 external access\"\necho \"=================================================\"",
      "container": "debian:bookworm-slim",
      "entrypoint": "bash"
    }
  },
  "variables": [
    {
      "name": "Auto-Update aktivieren",
      "description": "Automatische Updates bei Serverstart vom offiziellen Repository",
      "env_variable": "AUTO_UPDATE",
      "default_value": "true",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|string|in:true,false",
      "sort": 1,
      "field_type": "text"
    },
    {
      "name": "Node Environment",
      "description": "Node.js Umgebung (production empfohlen)",
      "env_variable": "NODE_ENV",
      "default_value": "production",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|string|in:production,development",
      "sort": 2,
      "field_type": "text"
    },
    {
      "name": "Admin Benutzername",
      "description": "Standard Admin Benutzername f√ºr erste Anmeldung",
      "env_variable": "ADMIN_USERNAME",
      "default_value": "admin",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|string|min:3|max:20",
      "sort": 3,
      "field_type": "text"
    },
    {
      "name": "Admin Passwort",
      "description": "Standard Admin Passwort (WICHTIG: Nach dem ersten Login √§ndern!)",
      "env_variable": "ADMIN_PASSWORD",
      "default_value": "admin123",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|string|min:6",
      "sort": 4,
      "field_type": "text"
    },
    {
      "name": "Session Secret",
      "description": "Geheimer Schl√ºssel f√ºr Sessions (mindestens 32 Zeichen, automatisch generiert)",
      "env_variable": "SESSION_SECRET",
      "default_value": "db-backup-session-secret-change-in-production-32chars-min",
      "user_viewable": false,
      "user_editable": true,
      "rules": "required|string|min:32",
      "sort": 5,
      "field_type": "text"
    },
    {
      "name": "JWT Secret",
      "description": "Geheimer Schl√ºssel f√ºr JWT Tokens (mindestens 32 Zeichen, automatisch generiert)",
      "env_variable": "JWT_SECRET",
      "default_value": "db-backup-jwt-secret-change-in-production-32chars-minimum",
      "user_viewable": false,
      "user_editable": true,
      "rules": "required|string|min:32",
      "sort": 6,
      "field_type": "text"
    },
    {
      "name": "Maximale Backups",
      "description": "Maximale Anzahl von Backups die gespeichert werden (Cleanup)",
      "env_variable": "MAX_BACKUPS",
      "default_value": "10",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|integer|min:1|max:100",
      "sort": 7,
      "field_type": "text"
    },
    {
    {
      "name": "Backup-Komprimierung",
      "description": "Aktiviert Komprimierung f√ºr Backups (empfohlen)",
      "env_variable": "ENABLE_COMPRESSION",
      "default_value": "true",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|string|in:true,false",
      "sort": 8,
      "field_type": "text"
    },
    {
      "name": "HTTPS aktivieren",
      "description": "Erzwingt HTTPS f√ºr die Anwendung (SSL-Zertifikat erforderlich)",
      "env_variable": "REQUIRE_HTTPS",
      "default_value": "true",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|string|in:true,false",
      "sort": 9,
      "field_type": "text"
    },
    {
      "name": "HTTPS Port",
      "description": "Port f√ºr den HTTPS-Server (Standard: 8443)",
      "env_variable": "HTTPS_PORT",
      "default_value": "8443",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|integer|min:1|max:65535",
      "sort": 10,
      "field_type": "text"
    },
    {
      "name": "SSL-Methode",
      "description": "SSL-Zertifikat Methode: selfsigned (Docker-sicher), letsencrypt (ben√∂tigt Port 80), manual (eigene Zertifikate)",
      "env_variable": "SSL_METHOD",
      "default_value": "selfsigned",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|string|in:selfsigned,letsencrypt,cloudflare,manual",
      "sort": 11,
      "field_type": "text"
    },
    {
      "name": "SSL Domain",
      "description": "Domain f√ºr SSL-Zertifikat (f√ºr Let's Encrypt: echte Domain erforderlich!)",
      "env_variable": "SSL_DOMAIN",
      "default_value": "brandy.exahost.de",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|string|min:3|max:255",
      "sort": 12,
      "field_type": "text"
    },
    {
      "name": "SSL Email",
      "description": "Email-Adresse f√ºr SSL-Zertifikat (erforderlich f√ºr Let's Encrypt)",
      "env_variable": "SSL_EMAIL",
      "default_value": "admin@brandy.exahost.de",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|string|min:5|max:255",
      "sort": 13,
      "field_type": "text"
    },
    {
      "name": "SSL Auto-Renewal",
      "description": "Automatische Erneuerung von SSL-Zertifikaten (f√ºr Let's Encrypt)",
      "env_variable": "SSL_AUTO_RENEWAL",
      "default_value": "true",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|string|in:true,false",
      "sort": 14,
      "field_type": "text"
    },
    {
      "name": "SSL Setup beim Start",
      "description": "F√ºhrt SSL-Setup automatisch beim Server-Start aus (Docker-optimiert)",
      "env_variable": "SSL_SETUP_ON_START",
      "default_value": "true",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|string|in:true,false",
      "sort": 15,
      "field_type": "text"
    },
    {
      "name": "SSL Key-Gr√∂√üe",
      "description": "RSA Schl√ºssel-Gr√∂√üe in Bits (4096 = sehr sicher, 2048 = Standard)",
      "env_variable": "SSL_KEY_SIZE",
      "default_value": "4096",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|integer|in:2048,4096",
      "sort": 16,
      "field_type": "text"
    },
    {
      "name": "SSL Zertifikat-G√ºltigkeit",
      "description": "G√ºltigkeit des SSL-Zertifikats in Tagen (nur f√ºr Self-Signed)",
      "env_variable": "SSL_CERT_VALIDITY",
      "default_value": "365",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|integer|min:30|max:3650",
      "sort": 17,
      "field_type": "text"
    },
    {
      "name": "Zwei-Faktor-Authentifizierung",
      "description": "Aktiviert 2FA f√ºr zus√§tzliche Sicherheit (empfohlen)",
      "env_variable": "ENABLE_2FA",
      "default_value": "false",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|string|in:true,false",
      "sort": 18,
      "field_type": "text"
    },
    {
      "name": "Starke Passw√∂rter erzwingen",
      "description": "Erzwingt starke Passw√∂rter (min. 12 Zeichen, Gro√ü-/Kleinbuchstaben, Zahlen, Sonderzeichen)",
      "env_variable": "STRONG_PASSWORDS",
      "default_value": "true",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|string|in:true,false",
      "sort": 19,
      "field_type": "text"
    },
    {
      "name": "Max. Login-Fehlversuche",
      "description": "Maximale Anzahl fehlgeschlagener Login-Versuche vor Sperrung",
      "env_variable": "MAX_FAILED_ATTEMPTS",
      "default_value": "5",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|integer|min:1|max:20",
      "sort": 20,
      "field_type": "text"
    },
    {
      "name": "Git Backup aktivieren",
      "description": "Automatisches Pushen von Backups zu Git Repository (GitHub, GitLab, etc.)",
      "env_variable": "GIT_BACKUP_ENABLED",
      "default_value": "false",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|string|in:true,false",
      "sort": 21,
      "field_type": "text"
    },
    {
      "name": "Git Repository URL",
      "description": "HTTPS URL des Git Repositories f√ºr Backups (z.B. https://github.com/user/backup-repo.git)",
      "env_variable": "GIT_BACKUP_REPOSITORY",
      "default_value": "",
      "user_viewable": true,
      "user_editable": true,
      "rules": "nullable|string|max:500",
      "sort": 22,
      "field_type": "text"
    },
    {
      "name": "Git Benutzername",
      "description": "Git Benutzername f√ºr Repository-Zugriff",
      "env_variable": "GIT_BACKUP_USERNAME",
      "default_value": "",
      "user_viewable": true,
      "user_editable": true,
      "rules": "nullable|string|max:100",
      "sort": 23,
      "field_type": "text"
    },
    {
      "name": "Git Access Token",
      "description": "Personal Access Token oder App Password f√ºr Git Repository (wird verschl√ºsselt gespeichert)",
      "env_variable": "GIT_BACKUP_TOKEN",
      "default_value": "",
      "user_viewable": false,
      "user_editable": true,
      "rules": "nullable|string|max:200",
      "sort": 24,
      "field_type": "text"
    },
    {
      "name": "Git Branch",
      "description": "Git Branch f√ºr Backups (Standard: main)",
      "env_variable": "GIT_BACKUP_BRANCH",
      "default_value": "main",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|string|max:50",
      "sort": 25,
      "field_type": "text"
    },
    {
      "name": "Cloudflare API Token",
      "description": "Cloudflare API Token f√ºr Cloudflare Origin Certificates (nur bei SSL_METHOD=cloudflare)",
      "env_variable": "CLOUDFLARE_API_TOKEN",
      "default_value": "",
      "user_viewable": false,
      "user_editable": true,
      "rules": "nullable|string|max:200",
      "sort": 26,
      "field_type": "text"
    }
  ]
}
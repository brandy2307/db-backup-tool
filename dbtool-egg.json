{
  "_comment": "DO NOT EDIT: FILE GENERATED AUTOMATICALLY BY PANEL",
  "meta": {
    "version": "PTDL_v2",
    "update_url": "https://github.com/brandy2307/db-backup-tool/blob/main/dbtool-egg.json"
  },
  "exported_at": "2024-12-15T14:40:56+00:00",
  "name": "DB Backup Tool (Port-Fixed - Complete)",
  "author": "brandy@example.com",
  "uuid": "db9f372e-01d7-4c9b-a109-e49990d68d46",
  "description": "Sicheres automatisiertes Datenbank-Backup-Tool mit SSL-Unterstützung - PORT-KONFIGURATION KORRIGIERT",
  "features": [
    "eula=false"
  ],
  "docker_images": {
    "ghcr.io/parkervcp/yolks:nodejs_18": "ghcr.io/parkervcp/yolks:nodejs_18"
  },
  "file_denylist": [],
  "startup": "cd /home/container && if [ ! -f \"db-backup-tool/package.json\" ]; then echo \"ERROR: package.json not found. Please reinstall the server.\"; exit 1; fi && cd db-backup-tool && npm start",
  "config": {
    "files": "{\r\n    \"db-backup-tool/config.json\": {\r\n        \"parser\": \"json\",\r\n        \"find\": {\r\n            \"server.port\": \"{{server.build.default.port}}\",\r\n            \"server.httpsPort\": \"{{env.HTTPS_PORT}}\",\r\n            \"server.host\": \"0.0.0.0\",\r\n            \"security.requireHttps\": \"{{env.REQUIRE_HTTPS}}\",\r\n            \"security.enable2FA\": \"{{env.ENABLE_2FA}}\",\r\n            \"security.strongPasswords\": \"{{env.STRONG_PASSWORDS}}\",\r\n            \"security.maxFailedAttempts\": \"{{env.MAX_FAILED_ATTEMPTS}}\",\r\n            \"security.defaultAdmin.username\": \"{{env.ADMIN_USERNAME}}\",\r\n            \"security.defaultAdmin.password\": \"{{env.ADMIN_PASSWORD}}\",\r\n            \"security.sessionSecret\": \"{{env.SESSION_SECRET}}\",\r\n            \"security.jwtSecret\": \"{{env.JWT_SECRET}}\",\r\n            \"ssl.domain\": \"{{env.SSL_DOMAIN}}\",\r\n            \"ssl.email\": \"{{env.SSL_EMAIL}}\",\r\n            \"ssl.method\": \"{{env.SSL_METHOD}}\",\r\n            \"ssl.autoRenewal\": \"{{env.SSL_AUTO_RENEWAL}}\",\r\n            \"ssl.keySize\": \"{{env.SSL_KEY_SIZE}}\",\r\n            \"ssl.certValidity\": \"{{env.SSL_CERT_VALIDITY}}\",\r\n            \"ssl.setupOnStart\": \"{{env.SSL_SETUP_ON_START}}\",\r\n            \"backup.maxBackups\": \"{{env.MAX_BACKUPS}}\",\r\n            \"backup.compression\": \"{{env.ENABLE_COMPRESSION}}\",\r\n            \"gitBackup.enabled\": \"{{env.GIT_BACKUP_ENABLED}}\",\r\n            \"gitBackup.repository\": \"{{env.GIT_BACKUP_REPOSITORY}}\",\r\n            \"gitBackup.username\": \"{{env.GIT_BACKUP_USERNAME}}\",\r\n            \"gitBackup.branch\": \"{{env.GIT_BACKUP_BRANCH}}\",\r\n            \"updates.autoUpdate\": \"{{env.AUTO_UPDATE}}\"\r\n        }\r\n    }\r\n}",
    "startup": "{\r\n    \"done\": \"Server läuft auf\"\r\n}",
    "logs": "{}",
    "stop": "^C"
  },
  "scripts": {
    "installation": {
      "script": "#!/bin/bash\n# Database Backup Tool Installation - PORT-KONFIGURATION KORRIGIERT\n\nset -e\n\ndeclare -r DIR=\"/mnt/server\"\ndeclare -r APP_DIR=\"${DIR}/db-backup-tool\"\n\n# Fest definiertes Repository\nREPO_URL=\"https://github.com/brandy2307/db-backup-tool.git\"\nREPO_BRANCH=\"main\"\n\necho \"=================================================\"\necho \"DB BACKUP TOOL INSTALLATION (PORT-FIXED)\"\necho \"=================================================\"\necho \"Repository: ${REPO_URL}\"\necho \"Branch: ${REPO_BRANCH}\"\necho \"Target: ${APP_DIR}\"\necho \"Features: Port-Fix + Enhanced SSL + Security\"\necho \"HTTP Port: ${HTTP_PORT:-8080}\"\necho \"HTTPS Port: ${HTTPS_PORT:-8443}\"\necho \"Let's Encrypt Port: ${LETSENCRYPT_PORT:-80}\"\necho \"=================================================\"\n\n# System Dependencies\necho \"[1/8] Installing system dependencies...\"\napt update\napt install -y wget curl gnupg2 software-properties-common git openssl ca-certificates lsb-release\n\n# Node.js\necho \"[2/8] Installing Node.js 18...\"\ncurl -fsSL https://deb.nodesource.com/setup_18.x | bash -\napt install -y nodejs\n\n# Database Tools\necho \"[3/8] Installing database tools...\"\napt install -y mysql-client || echo \"MySQL client optional\"\napt install -y postgresql-client || echo \"PostgreSQL client optional\"\napt install -y mongodb-database-tools || echo \"MongoDB tools optional\"\n\n# SSL Tools + Network Tools für Port-Checks\necho \"[4/8] Installing SSL and network tools...\"\napt install -y certbot openssl ca-certificates net-tools\n\n# Git Setup\necho \"[5/8] Configuring Git...\"\ngit config --global init.defaultBranch main\ngit config --global user.name \"DB Backup Tool\"\ngit config --global user.email \"backup@localhost\"\n\n# Repository Clone\necho \"[6/8] Cloning repository...\"\ncd \"${DIR}\"\nrm -rf \"${APP_DIR}\" 2>/dev/null || true\ngit clone -b \"${REPO_BRANCH}\" \"${REPO_URL}\" \"${APP_DIR}\"\ncd \"${APP_DIR}\"\n\n# Dependencies\necho \"[7/8] Installing dependencies...\"\nnpm cache clean --force\nnpm install --production --no-audit --no-fund\n\n# Directory Setup\necho \"Creating directories...\"\nmkdir -p backups logs config public ssl\nchmod 700 ssl\nchmod 755 backups logs config public\n\n# SSL Setup mit Port-Konfiguration\necho \"[8/8] Setting up SSL with port configuration...\"\nif [ \"${SSL_SETUP_ON_START:-true}\" = \"true\" ] && [ \"${REQUIRE_HTTPS:-false}\" = \"true\" ]; then\n    echo \"🔐 SSL-Setup wird vorbereitet mit Port-Konfiguration...\"\n    \n    # Port-Variablen setzen\n    export SSL_DOMAIN=\"${SSL_DOMAIN:-localhost}\"\n    export SSL_METHOD=\"${SSL_METHOD:-selfsigned}\"\n    export SSL_KEY_SIZE=\"${SSL_KEY_SIZE:-4096}\"\n    export SSL_CERT_VALIDITY=\"${SSL_CERT_VALIDITY:-365}\"\n    export HTTP_PORT=\"${HTTP_PORT:-8080}\"\n    export HTTPS_PORT=\"${HTTPS_PORT:-8443}\"\n    export LETSENCRYPT_PORT=\"${LETSENCRYPT_PORT:-80}\"\n    \n    echo \"🌐 Port-Konfiguration:\"\n    echo \"   HTTP Port: ${HTTP_PORT}\"\n    echo \"   HTTPS Port: ${HTTPS_PORT}\"\n    echo \"   Let's Encrypt Port: ${LETSENCRYPT_PORT}\"\n    \n    # Enhanced SSL-Setup Script mit Port-Fix erstellen\n    cat > ./ssl-setup.sh << 'EOF'\n#!/bin/bash\nset -e\n\n# Port-Konfiguration aus Umgebungsvariablen\nSSL_DOMAIN=\"${SSL_DOMAIN:-localhost}\"\nSSL_METHOD=\"${SSL_METHOD:-selfsigned}\"\nSSL_KEY_SIZE=\"${SSL_KEY_SIZE:-4096}\"\nSSL_CERT_VALIDITY=\"${SSL_CERT_VALIDITY:-365}\"\nHTTP_PORT=\"${HTTP_PORT:-8080}\"\nHTTPS_PORT=\"${HTTPS_PORT:-8443}\"\nLETSENCRYPT_PORT=\"${LETSENCRYPT_PORT:-80}\"\n\necho \"🔐 SSL-Setup für ${SSL_DOMAIN} (Methode: ${SSL_METHOD})\"\necho \"🌐 Port-Konfiguration: HTTP=${HTTP_PORT}, HTTPS=${HTTPS_PORT}, LE=${LETSENCRYPT_PORT}\"\n\nmkdir -p ssl\nchmod 700 ssl\n\n# Port-Verfügbarkeit prüfen\ncheck_port() {\n    local port=$1\n    local name=$2\n    echo \"🔍 Prüfe Port ${port} (${name})...\"\n    \n    if command -v netstat >/dev/null 2>&1; then\n        if netstat -tlnp 2>/dev/null | grep -q \":${port} \"; then\n            echo \"⚠️ Port ${port} ist belegt\"\n            return 1\n        fi\n    elif command -v ss >/dev/null 2>&1; then\n        if ss -tlnp 2>/dev/null | grep -q \":${port} \"; then\n            echo \"⚠️ Port ${port} ist belegt\"\n            return 1\n        fi\n    fi\n    \n    echo \"✅ Port ${port} verfügbar\"\n    return 0\n}\n\n# HTTPS Port validieren\nif ! check_port \"${HTTPS_PORT}\" \"HTTPS\"; then\n    echo \"❌ HTTPS Port ${HTTPS_PORT} ist nicht verfügbar\"\n    echo \"💡 Bitte anderen Port wählen oder belegenden Service stoppen\"\n    exit 1\nfi\n\nif [ \"${SSL_METHOD}\" = \"selfsigned\" ]; then\n    echo \"🔄 Erstelle Enhanced Self-Signed Zertifikat...\"\n    \n    # Enhanced OpenSSL Config für Browser-Kompatibilität\n    cat > ssl/openssl.cnf << 'SSLCONF'\n[req]\ndistinguished_name = req_distinguished_name\nreq_extensions = v3_req\nprompt = no\nx509_extensions = v3_ca\n\n[req_distinguished_name]\nC = DE\nST = NRW\nL = Docker\nO = DB Backup Tool\nCN = DOMAIN_PLACEHOLDER\n\n[v3_req]\nbasicConstraints = CA:FALSE\nkeyUsage = nonRepudiation, digitalSignature, keyEncipherment\nextendedKeyUsage = serverAuth, clientAuth\nsubjectAltName = @alt_names\n\n[v3_ca]\nbasicConstraints = CA:FALSE\nkeyUsage = nonRepudiation, digitalSignature, keyEncipherment\nextendedKeyUsage = serverAuth, clientAuth\nsubjectAltName = @alt_names\n\n[alt_names]\nDNS.1 = DOMAIN_PLACEHOLDER\nDNS.2 = localhost\nIP.1 = 127.0.0.1\nIP.2 = ::1\nSSLCONF\n    \n    # Domain in Config einsetzen\n    sed -i \"s/DOMAIN_PLACEHOLDER/${SSL_DOMAIN}/g\" ssl/openssl.cnf\n    \n    # Zertifikat erstellen mit Enhanced KeyUsage\n    openssl req -x509 -newkey rsa:${SSL_KEY_SIZE} \\\n        -keyout ssl/privkey.pem \\\n        -out ssl/fullchain.pem \\\n        -days ${SSL_CERT_VALIDITY} \\\n        -nodes \\\n        -config ssl/openssl.cnf \\\n        -extensions v3_ca\n    \n    rm -f ssl/openssl.cnf\n    \n    # Validierung\n    if openssl x509 -in ssl/fullchain.pem -text -noout | grep -q \"digitalSignature\"; then\n        echo \"✅ Enhanced SSL-Zertifikat mit korrekter KeyUsage erstellt\"\n        echo \"🌐 Browser-Kompatibilität: ERR_SSL_KEY_USAGE_INCOMPATIBLE behoben\"\n        echo \"🚪 HTTPS Port: ${HTTPS_PORT}\"\n    else\n        echo \"⚠️ KeyUsage möglicherweise nicht optimal\"\n    fi\n    \nelif [ \"${SSL_METHOD}\" = \"letsencrypt\" ]; then\n    echo \"🔄 Let's Encrypt Setup mit Port-Konfiguration...\"\n    \n    # Validierung für Let's Encrypt\n    if [ \"${SSL_DOMAIN}\" = \"localhost\" ]; then\n        echo \"❌ Let's Encrypt funktioniert nicht mit localhost\"\n        echo \"🔄 Verwende Self-Signed Fallback\"\n        SSL_METHOD=\"selfsigned\"\n        exec \"$0\"\n    fi\n    \n    # Let's Encrypt Port prüfen\n    if ! check_port \"${LETSENCRYPT_PORT}\" \"Let's Encrypt\"; then\n        echo \"⚠️ Let's Encrypt Port ${LETSENCRYPT_PORT} belegt - stoppe Services\"\n        systemctl stop nginx 2>/dev/null || true\n        systemctl stop apache2 2>/dev/null || true\n        systemctl stop httpd 2>/dev/null || true\n        \n        sleep 2\n        if ! check_port \"${LETSENCRYPT_PORT}\" \"Let's Encrypt\"; then\n            echo \"❌ Port ${LETSENCRYPT_PORT} konnte nicht freigegeben werden\"\n            echo \"🔄 Verwende Self-Signed Fallback\"\n            SSL_METHOD=\"selfsigned\"\n            exec \"$0\"\n        fi\n    fi\n    \n    # Certbot installieren falls nicht vorhanden\n    if ! command -v certbot >/dev/null 2>&1; then\n        echo \"📦 Installiere Certbot...\"\n        apt-get update >/dev/null 2>&1\n        apt-get install -y certbot >/dev/null 2>&1\n    fi\n    \n    # Let's Encrypt Zertifikat holen\n    echo \"📡 Hole Let's Encrypt Zertifikat (Port: ${LETSENCRYPT_PORT})...\"\n    if certbot certonly --standalone --non-interactive --agree-tos \\\n        --email \"${SSL_EMAIL:-admin@${SSL_DOMAIN}}\" \\\n        --domains \"${SSL_DOMAIN}\" \\\n        --key-type rsa --rsa-key-size \"${SSL_KEY_SIZE}\" \\\n        --http-01-port \"${LETSENCRYPT_PORT}\"; then\n        \n        # Zertifikate kopieren\n        if [ -d \"/etc/letsencrypt/live/${SSL_DOMAIN}\" ]; then\n            cp \"/etc/letsencrypt/live/${SSL_DOMAIN}/fullchain.pem\" ssl/fullchain.pem\n            cp \"/etc/letsencrypt/live/${SSL_DOMAIN}/privkey.pem\" ssl/privkey.pem\n            echo \"✅ Let's Encrypt Zertifikat erstellt\"\n            echo \"🚪 HTTPS Port: ${HTTPS_PORT}\"\n        else\n            echo \"❌ Let's Encrypt Zertifikat-Verzeichnis nicht gefunden\"\n            echo \"🔄 Verwende Self-Signed Fallback\"\n            SSL_METHOD=\"selfsigned\"\n            exec \"$0\"\n        fi\n    else\n        echo \"❌ Let's Encrypt fehlgeschlagen\"\n        echo \"🔄 Verwende Self-Signed Fallback\"\n        SSL_METHOD=\"selfsigned\"\n        exec \"$0\"\n    fi\n    \nelse\n    echo \"⚠️ SSL-Methode ${SSL_METHOD} - verwende Self-Signed Fallback\"\n    SSL_METHOD=\"selfsigned\"\n    exec \"$0\"\nfi\n\n# Berechtigungen setzen\nchmod 644 ssl/fullchain.pem 2>/dev/null || true\nchmod 600 ssl/privkey.pem 2>/dev/null || true\n\n# Validierung\nif openssl x509 -in ssl/fullchain.pem -text -noout >/dev/null 2>&1; then\n    echo \"✅ SSL-Zertifikat erfolgreich validiert\"\n    echo \"📋 Zertifikat-Details:\"\n    openssl x509 -in ssl/fullchain.pem -subject -dates -noout 2>/dev/null || echo \"Details nicht verfügbar\"\n    echo \"🌐 Port-Info:\"\n    echo \"   HTTP: ${HTTP_PORT}\"\n    echo \"   HTTPS: ${HTTPS_PORT}\"\nelse\n    echo \"❌ SSL-Zertifikat ungültig\"\n    exit 1\nfi\n\necho \"🎉 SSL-Setup mit Port-Konfiguration abgeschlossen!\"\nEOF\n    \n    chmod +x ./ssl-setup.sh\n    \n    # SSL-Setup ausführen\n    echo \"🔄 Führe SSL-Setup mit Port-Konfiguration aus...\"\n    if ./ssl-setup.sh; then\n        echo \"✅ SSL-Setup erfolgreich\"\n        if [ -f \"ssl/fullchain.pem\" ] && [ -f \"ssl/privkey.pem\" ]; then\n            echo \"🔐 HTTPS-Zertifikate erstellt\"\n            echo \"🌐 Enhanced Browser-Kompatibilität aktiviert\"\n            echo \"🚪 HTTPS Port: ${HTTPS_PORT}\"\n        fi\n    else\n        echo \"⚠️ SSL-Setup fehlgeschlagen - HTTP Fallback aktiv\"\n    fi\nelse\n    echo \"ℹ️ SSL-Setup übersprungen (deaktiviert)\"\nfi\n\n# Finale Berechtigungen\nchmod 755 .\nchmod 644 *.json *.js *.md 2>/dev/null || true\nchmod +x *.sh 2>/dev/null || true\n\n# Grundlegende Dateien erstellen\ntouch logs/security.log\necho \"[]\" > backups/schedules.json 2>/dev/null || true\necho \"* text=auto\" > .gitattributes 2>/dev/null || true\n\n# Validierung\necho \"Validiere Installation...\"\nif node -e \"JSON.parse(require('fs').readFileSync('package.json', 'utf8'))\" 2>/dev/null; then\n    echo \"✅ package.json gültig\"\nelse\n    echo \"❌ package.json ungültig\"\n    exit 1\nfi\n\necho \"=================================================\"\necho \"🎉 INSTALLATION ERFOLGREICH ABGESCHLOSSEN!\"\necho \"=================================================\"\necho \"✅ Repository: ${REPO_URL}\"\necho \"✅ Branch: ${REPO_BRANCH}\"\necho \"✅ Node.js: $(node --version 2>/dev/null || echo 'Unknown')\"\necho \"✅ NPM: $(npm --version 2>/dev/null || echo 'Unknown')\"\necho \"✅ Port-Fix: Dynamische Port-Konfiguration aktiviert\"\necho \"✅ Enhanced SSL: Browser-Kompatibilität verbessert\"\necho \"✅ Security Features: 2FA, CAPTCHA, Rate Limiting\"\necho \"✅ Database Support: MySQL, PostgreSQL, MongoDB\"\necho \"✅ Git Backup: Unterstützt\"
echo \"✅ Auto-Update: Aktiviert\"

echo \"🌐 PORT-KONFIGURATION:\"
echo \"   HTTP Port: ${HTTP_PORT:-8080}\"
echo \"   HTTPS Port: ${HTTPS_PORT:-8443}\"
echo \"   Let's Encrypt Port: ${LETSENCRYPT_PORT:-80}\"

if [ -f \"ssl/fullchain.pem\" ] && [ -f \"ssl/privkey.pem\" ]; then
    echo \"🔐 SSL Status: Zertifikate verfügbar\"
    echo \"🌐 Browser Fix: ERR_SSL_KEY_USAGE_INCOMPATIBLE behoben\"
    echo \"🚪 HTTPS verfügbar auf Port: ${HTTPS_PORT:-8443}\"
else
    echo \"ℹ️ SSL Status: Wird beim ersten Start erstellt\"
fi

echo \"=================================================\"
echo \"🚀 SERVER BEREIT ZUM STARTEN!\"
echo \"🔧 Konfiguration über Pterodactyl Umgebungsvariablen\"
echo \"📝 Standard Login: admin / admin123 (bitte ändern!)\"
echo \"🌐 URL: https://[deine-domain]:${HTTPS_PORT:-8443}\"
echo \"=================================================\"",
      "container": "debian:bookworm-slim",
      "entrypoint": "bash"
    }
  },
  "variables": [
    {
      "name": "Auto-Update aktivieren",
      "description": "Automatische Updates bei Serverstart vom offiziellen Repository",
      "env_variable": "AUTO_UPDATE",
      "default_value": "true",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|string|in:true,false",
      "sort": 1,
      "field_type": "text"
    },
    {
      "name": "Node Environment",
      "description": "Node.js Umgebung (production empfohlen)",
      "env_variable": "NODE_ENV",
      "default_value": "production",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|string|in:production,development",
      "sort": 2,
      "field_type": "text"
    },
    {
      "name": "Admin Benutzername",
      "description": "Standard Admin Benutzername für erste Anmeldung",
      "env_variable": "ADMIN_USERNAME",
      "default_value": "admin",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|string|min:3|max:20",
      "sort": 3,
      "field_type": "text"
    },
    {
      "name": "Admin Passwort",
      "description": "Standard Admin Passwort (WICHTIG: Nach dem ersten Login ändern!)",
      "env_variable": "ADMIN_PASSWORD",
      "default_value": "admin123",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|string|min:6",
      "sort": 4,
      "field_type": "text"
    },
    {
      "name": "Session Secret",
      "description": "Geheimer Schlüssel für Sessions (mindestens 32 Zeichen, automatisch generiert)",
      "env_variable": "SESSION_SECRET",
      "default_value": "db-backup-session-secret-change-in-production-32chars-min",
      "user_viewable": false,
      "user_editable": true,
      "rules": "required|string|min:32",
      "sort": 5,
      "field_type": "text"
    },
    {
      "name": "JWT Secret",
      "description": "Geheimer Schlüssel für JWT Tokens (mindestens 32 Zeichen, automatisch generiert)",
      "env_variable": "JWT_SECRET",
      "default_value": "db-backup-jwt-secret-change-in-production-32chars-minimum",
      "user_viewable": false,
      "user_editable": true,
      "rules": "required|string|min:32",
      "sort": 6,
      "field_type": "text"
    },
    {
      "name": "Maximale Backups",
      "description": "Maximale Anzahl von Backups die gespeichert werden (Cleanup)",
      "env_variable": "MAX_BACKUPS",
      "default_value": "10",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|integer|min:1|max:100",
      "sort": 7,
      "field_type": "text"
    },
    {
      "name": "Backup-Komprimierung",
      "description": "Aktiviert Komprimierung für Backups (empfohlen)",
      "env_variable": "ENABLE_COMPRESSION",
      "default_value": "true",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|string|in:true,false",
      "sort": 8,
      "field_type": "text"
    },
    {
      "name": "HTTP Port",
      "description": "Port für HTTP-Verkehr und Weiterleitungen (Standard: wird von Pterodactyl gesetzt)",
      "env_variable": "HTTP_PORT",
      "default_value": "{{server.build.default.port}}",
      "user_viewable": true,
      "user_editable": false,
      "rules": "required|integer|min:1|max:65535",
      "sort": 9,
      "field_type": "text"
    },
    {
      "name": "HTTPS aktivieren",
      "description": "Erzwingt HTTPS für die Anwendung (SSL-Zertifikat erforderlich)",
      "env_variable": "REQUIRE_HTTPS",
      "default_value": "true",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|string|in:true,false",
      "sort": 10,
      "field_type": "text"
    },
    {
      "name": "HTTPS Port",
      "description": "Port für den HTTPS-Server (Standard: 8443, muss sich vom HTTP Port unterscheiden)",
      "env_variable": "HTTPS_PORT",
      "default_value": "8443",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|integer|min:1|max:65535",
      "sort": 11,
      "field_type": "text"
    },
    {
      "name": "Let's Encrypt Port",
      "description": "Port für Let's Encrypt HTTP-Challenge (Standard: 80, nur für Let's Encrypt benötigt)",
      "env_variable": "LETSENCRYPT_PORT",
      "default_value": "80",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|integer|min:1|max:65535",
      "sort": 12,
      "field_type": "text"
    },
    {
      "name": "SSL-Methode",
      "description": "SSL-Zertifikat Methode: selfsigned (empfohlen für Docker), letsencrypt (benötigt öffentliche Domain), cloudflare (Origin Cert), manual (eigene Zertifikate)",
      "env_variable": "SSL_METHOD",
      "default_value": "selfsigned",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|string|in:selfsigned,letsencrypt,cloudflare,manual",
      "sort": 13,
      "field_type": "text"
    },
    {
      "name": "SSL Domain",
      "description": "Domain für SSL-Zertifikat (für Let's Encrypt: echte öffentliche Domain erforderlich!)",
      "env_variable": "SSL_DOMAIN",
      "default_value": "brandy.exahost.de",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|string|min:3|max:255",
      "sort": 14,
      "field_type": "text"
    },
    {
      "name": "SSL Email",
      "description": "Email-Adresse für SSL-Zertifikat (erforderlich für Let's Encrypt)",
      "env_variable": "SSL_EMAIL",
      "default_value": "admin@brandy.exahost.de",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|string|min:5|max:255",
      "sort": 15,
      "field_type": "text"
    },
    {
      "name": "SSL Auto-Renewal",
      "description": "Automatische Erneuerung von SSL-Zertifikaten (für Let's Encrypt und Cloudflare)",
      "env_variable": "SSL_AUTO_RENEWAL",
      "default_value": "true",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|string|in:true,false",
      "sort": 16,
      "field_type": "text"
    },
    {
      "name": "SSL Setup beim Start",
      "description": "Führt SSL-Setup automatisch beim Server-Start aus mit Port-Validierung",
      "env_variable": "SSL_SETUP_ON_START",
      "default_value": "true",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|string|in:true,false",
      "sort": 17,
      "field_type": "text"
    },
    {
      "name": "SSL Key-Größe",
      "description": "RSA Schlüssel-Größe in Bits (4096 = sehr sicher, 2048 = Standard)",
      "env_variable": "SSL_KEY_SIZE",
      "default_value": "4096",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|integer|in:2048,4096",
      "sort": 18,
      "field_type": "text"
    },
    {
      "name": "SSL Zertifikat-Gültigkeit",
      "description": "Gültigkeit des SSL-Zertifikats in Tagen (nur für Self-Signed und Cloudflare)",
      "env_variable": "SSL_CERT_VALIDITY",
      "default_value": "365",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|integer|min:30|max:3650",
      "sort": 19,
      "field_type": "text"
    },
    {
      "name": "Zwei-Faktor-Authentifizierung",
      "description": "Aktiviert 2FA für zusätzliche Sicherheit (empfohlen)",
      "env_variable": "ENABLE_2FA",
      "default_value": "false",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|string|in:true,false",
      "sort": 20,
      "field_type": "text"
    },
    {
      "name": "Starke Passwörter erzwingen",
      "description": "Erzwingt starke Passwörter (min. 12 Zeichen, Groß-/Kleinbuchstaben, Zahlen, Sonderzeichen)",
      "env_variable": "STRONG_PASSWORDS",
      "default_value": "true",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|string|in:true,false",
      "sort": 21,
      "field_type": "text"
    },
    {
      "name": "Max. Login-Fehlversuche",
      "description": "Maximale Anzahl fehlgeschlagener Login-Versuche vor Sperrung",
      "env_variable": "MAX_FAILED_ATTEMPTS",
      "default_value": "5",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|integer|min:1|max:20",
      "sort": 22,
      "field_type": "text"
    },
    {
      "name": "Git Backup aktivieren",
      "description": "Automatisches Pushen von Backups zu Git Repository (GitHub, GitLab, etc.)",
      "env_variable": "GIT_BACKUP_ENABLED",
      "default_value": "false",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|string|in:true,false",
      "sort": 23,
      "field_type": "text"
    },
    {
      "name": "Git Repository URL",
      "description": "HTTPS URL des Git Repositories für Backups (z.B. https://github.com/user/backup-repo.git)",
      "env_variable": "GIT_BACKUP_REPOSITORY",
      "default_value": "",
      "user_viewable": true,
      "user_editable": true,
      "rules": "nullable|string|max:500",
      "sort": 24,
      "field_type": "text"
    },
    {
      "name": "Git Benutzername",
      "description": "Git Benutzername für Repository-Zugriff",
      "env_variable": "GIT_BACKUP_USERNAME",
      "default_value": "",
      "user_viewable": true,
      "user_editable": true,
      "rules": "nullable|string|max:100",
      "sort": 25,
      "field_type": "text"
    },
    {
      "name": "Git Access Token",
      "description": "Personal Access Token oder App Password für Git Repository (wird verschlüsselt gespeichert)",
      "env_variable": "GIT_BACKUP_TOKEN",
      "default_value": "",
      "user_viewable": false,
      "user_editable": true,
      "rules": "nullable|string|max:200",
      "sort": 26,
      "field_type": "text"
    },
    {
      "name": "Git Branch",
      "description": "Git Branch für Backups (Standard: main)",
      "env_variable": "GIT_BACKUP_BRANCH",
      "default_value": "main",
      "user_viewable": true,
      "user_editable": true,
      "rules": "required|string|max:50",
      "sort": 27,
      "field_type": "text"
    },
    {
      "name": "Cloudflare API Token",
      "description": "Cloudflare API Token für Cloudflare Origin Certificates (nur bei SSL_METHOD=cloudflare erforderlich)",
      "env_variable": "CLOUDFLARE_API_TOKEN",
      "default_value": "",
      "user_viewable": false,
      "user_editable": true,
      "rules": "nullable|string|max:200",
      "sort": 28,
      "field_type": "text"
    }
  ]
}